import path from "path";
import fs from "fs-extra";
import type { CreateConfig } from "../types/config";

const TEXT_EXT = new Set([
  ".ts",
  ".tsx",
  ".js",
  ".jsx",
  ".json",
  ".md",
  ".txt",
  ".go",
  ".mod",
  ".sum",
  ".java",
  ".yml",
  ".yaml",
  ".xml",
  ".properties",
  ".env",
  ".gitignore",
  ".sh",
  ".py",
  ".toml",
  ".cfg",
  ".ini",
  ".sql",
  ".html",
  ".css",
]);

function templateRoot() {
  return path.resolve(__dirname, "..", "templates");
}

function replacements(config: CreateConfig): Record<string, string> {
  return {
    PROJECT_NAME: config.projectName,
    BACKEND_MAIN: config.backendMain,
    FRONTEND: config.frontend,
    DATA_MODULES: config.dataModules.join(", "),
    EXTRA_MODULES: config.extraModules.join(", ") || "none",
  };
}

async function renderTextFile(file: string, map: Record<string, string>) {
  const ext = path.extname(file);
  const base = path.basename(file);
  if (!TEXT_EXT.has(ext) && !TEXT_EXT.has(base)) return;
  const content = await fs.readFile(file, "utf8");
  const rendered = content.replace(/\{\{([A-Z0-9_]+)\}\}/g, (_m, key: string) => map[key] ?? "");
  if (content !== rendered) {
    await fs.writeFile(file, rendered, "utf8");
  }
}

async function renderDir(target: string, map: Record<string, string>) {
  const entries = await fs.readdir(target, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(target, entry.name);
    if (entry.isDirectory()) {
      await renderDir(full, map);
    } else {
      await renderTextFile(full, map);
    }
  }
}

async function mergeTemplate(templateDir: string, targetDir: string, map: Record<string, string>) {
  const source = path.join(templateRoot(), templateDir);
  if (!(await fs.pathExists(source))) return;
  await fs.copy(source, targetDir, { overwrite: true });
  await renderDir(targetDir, map);
}

async function ensureExecutableScripts(targetDir: string) {
  const scripts = [
    path.join(targetDir, "infra", "scripts", "dev.sh"),
    path.join(targetDir, "infra", "scripts", "build.sh"),
    path.join(targetDir, "infra", "scripts", "test.sh"),
    path.join(targetDir, "infra", "scripts", "check.sh"),
  ];
  for (const script of scripts) {
    if (await fs.pathExists(script)) {
      await fs.chmod(script, 0o755);
    }
  }
}

function dockerServices(config: CreateConfig): string {
  const services: string[] = [];
  if (config.dataModules.includes("mysql")) {
    services.push(`  mysql:\n    image: mysql:8\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n      MYSQL_DATABASE: app\n    ports:\n      - \"3306:3306\"`);
  }
  if (config.dataModules.includes("postgresql")) {
    services.push(`  postgresql:\n    image: postgres:16\n    environment:\n      POSTGRES_PASSWORD: postgres\n      POSTGRES_DB: app\n    ports:\n      - \"5432:5432\"`);
  }
  if (config.dataModules.includes("redis")) {
    services.push(`  redis:\n    image: redis:7\n    ports:\n      - \"6379:6379\"`);
  }
  if (config.dataModules.includes("mongodb")) {
    services.push(`  mongodb:\n    image: mongo:7\n    ports:\n      - \"27017:27017\"`);
  }
  if (config.extraModules.includes("python-worker")) {
    services.push(`  worker-python:\n    build:\n      context: ../apps/worker-python\n    command: python worker.py`);
  }
  return services.join("\n\n");
}

async function writeGeneratedReadme(config: CreateConfig) {
  const readme = `# ${config.projectName}\n\nGenerated by scaffold-hybrid-cli.\n\n## Stack\n- Frontend: ${config.frontend}\n- Backend: ${config.backendMain}\n- Extra modules: ${config.extraModules.join(", ") || "none"}\n- Data modules: ${config.dataModules.join(", ")}\n\n## Quick Start\n\n\`\`\`bash\n# basic sanity checks\nnpm run check\n\n# start local dev flow\nnpm run dev\n\n# build\nnpm run build\n\n# test\nnpm run test\n\`\`\`\n\nHealth endpoint: \`/health\`\n`;
  await fs.writeFile(path.join(config.targetDir, "README.md"), readme, "utf8");
}

async function updateGitignoreForSqlite(config: CreateConfig) {
  if (!config.dataModules.includes("sqlite")) return;
  const gitignorePath = path.join(config.targetDir, ".gitignore");
  const exists = await fs.pathExists(gitignorePath);
  const marker = "data/*.db";
  if (!exists) {
    await fs.writeFile(gitignorePath, `${marker}\n`, "utf8");
    return;
  }
  const content = await fs.readFile(gitignorePath, "utf8");
  if (!content.includes(marker)) {
    await fs.writeFile(gitignorePath, `${content.trimEnd()}\n${marker}\n`, "utf8");
  }
}

async function maybeWriteDocker(config: CreateConfig) {
  if (!config.docker) return;
  const dockerDir = path.join(config.targetDir, "infra", "docker");
  await fs.ensureDir(dockerDir);
  const compose = `services:\n${dockerServices(config) || "  # add services here"}\n`;
  await fs.writeFile(path.join(dockerDir, "docker-compose.yml"), compose, "utf8");
}

export async function renderProject(config: CreateConfig): Promise<void> {
  const target = config.targetDir;
  if (await fs.pathExists(target)) {
    throw new Error(`target directory already exists: ${target}`);
  }

  await fs.ensureDir(target);
  const map = replacements(config);

  await mergeTemplate("base", target, map);
  await mergeTemplate(path.join("backend", config.backendMain), target, map);

  if (config.frontend !== "none") {
    await mergeTemplate(path.join("frontend", config.frontend), target, map);
  }

  for (const module of config.extraModules) {
    await mergeTemplate(path.join("modules", module), target, map);
  }

  for (const data of config.dataModules) {
    if (data === "none") continue;
    await mergeTemplate(path.join("data", data), target, map);
  }

  await maybeWriteDocker(config);
  await updateGitignoreForSqlite(config);
  await writeGeneratedReadme(config);
  await ensureExecutableScripts(target);
}
